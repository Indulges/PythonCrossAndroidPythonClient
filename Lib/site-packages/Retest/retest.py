#encoding = utf-8
import os
import openpyxl
import re
class retest():
    def __init__(self):
        self.xlsx_path = os.getcwd() + "\pythonrematch.xlsx"
        self.conbine_pattern_dict = {}
        self.fragmentation_pattern_dict = {}
        self.log_example_column_name = 'LogExample'
        self.is_tag_fixed_column_name = 'IsTagFixed'
        self.target_column_name = 'TargetStr'
        self.pattern_column_name = 'Pattern'
        self.is_target_data_line = 'IsTargetDataLine'
        self.log_id = 'LogId'
        self.log_id.split()
        self.special_word = ['(', ')']
        self.fitter_mode = 0 #统合模式 所有正则表达式将会统合成一个正则表达式进行匹配，对电脑性能要求低一点， 1分片模式 对所有字段进行分片匹配，容错率高，但是对电脑性能影响更大
        self.result_split_word_list = ['=', ':', ' ']

    def load_xlsx(self):
        xlsx = openpyxl.load_workbook(self.xlsx_path)
        sheet_name_list = xlsx.sheetnames
        for sheet_name in sheet_name_list:
            sheet = xlsx[sheet_name]
            self.parse_sheet(sheet)

    def parse_sheet(self, sheet):
        title_dict = self.get_title_dict(sheet)
        log_id = 0
        for i in range(1, sheet.max_row + 1):
            print("row = {0}".format(i))
            log_example = None
            target_dict = {}
            is_target_fixed = False
            log_id = sheet.cell(i, title_dict[self.log_id]).value
            if sheet.cell(i, title_dict[self.is_target_data_line]).value == 1:
                print('该行为数据行，已在上一次循环进行加载')
                continue
            if sheet.cell(i, title_dict[self.is_target_data_line]).value == 0: #非数据行
                if sheet.cell(i, title_dict[self.pattern_column_name]).value is not None:
                    pattern = sheet.cell(i, title_dict[self.pattern_column_name]).value
                    self.conbine_pattern_dict[log_id] = pattern
                    continue
                if i != 1:
                    log_example = sheet.cell(i, title_dict[self.log_example_column_name]).value
                for j in range(1, sheet.max_column + 1):
                    if i!=1 and j == title_dict[self.is_tag_fixed_column_name]:#tag是否固定不变
                        is_target_fixed = sheet.cell(i, j).value == 1
                    elif j >= title_dict[self.target_column_name]:#获取需要过滤的目标数据及数据结尾
                        if sheet.cell(i, j).value is not None:
                            target_dict[j] = sheet.cell(i, j).value
                if log_example is not None:
                    self.get_pattern(log_example, is_target_fixed, target_dict, log_id)
                data_row = i + 1
                id = sheet.cell(data_row, title_dict[self.log_id]).value
                print('id = {0}'.format(id))
                while(sheet.cell(data_row, title_dict[self.is_target_data_line]).value == 1 and data_row < sheet.max_row + 1 is not None and log_id == id):
                    print('对正则表达式进行验证')
                    if self.fitter_mode == 0:
                        self.result_resolve_conbine(log_id, log_example,sheet,data_row, target_dict)
                    else:
                        self.result_resolve_fragmentation(log_id, log_example,sheet,data_row, target_dict)
                    data_row += 1



    def get_title_dict(self, sheet):
        title_dict = {}
        for j in range(1, sheet.max_column + 1):
            if sheet.cell(1, j).value is not None:  # 获取数据title
                title_dict[sheet.cell(1, j).value] = j
        return title_dict

    def get_pattern(self, log_example, is_target_fixed, target_dict, log_id):
        sub_pattern = ''
        tag_pattern = ''
        if is_target_fixed is True:
            tag_pattern = self.get_log_tag_pattern(log_example)
        for index,target in enumerate(target_dict):
            if target_dict.get(target) is None:
                continue
            target_and_end = target_dict.get(target).split('|')
            if target_and_end[1] in self.special_word:
                pattern = '.*(' + '?P<'+ target_and_end[0] +'>' + target_and_end[0] + '.*?)\\' + target_and_end[1] + '.*'
            elif target_and_end[1] == '':
                pattern = '.*('+ '?P<'+ target_and_end[0] +'>' + target_and_end[0] + '.*)'
            else:
                pattern = '.*(' + '?P<'+ target_and_end[0] +'>' + target_and_end[0] + '.*?)' + target_and_end[1] + '.*'
            pattern = self.get_regular_expression(log_example, pattern, target_and_end)
            # print(pattern)
            if self.fitter_mode == 0:#统合模式
                if index == 0:
                    if is_target_fixed is True:
                        sub_pattern = tag_pattern + pattern
                    sub_pattern = sub_pattern[0: -2]
                    pass
                elif index != len(target_dict) -1:
                    sub_pattern = sub_pattern + pattern[0: -2]
                else:
                    sub_pattern = sub_pattern + pattern
            elif self.fitter_mode == 1:#分片模式
                pattern_list = []
                if self.fragmentation_pattern_dict.keys().__contains__(log_id):
                    pattern_list = self.fragmentation_pattern_dict[log_id]
                    if pattern_list.__contains__(pattern):
                        print('不添加重复内容')
                    else:
                        pattern_list.append(pattern)
                else:
                    pattern_list.append(pattern)
                self.fragmentation_pattern_dict[log_id] = pattern_list
            # self.pattern_test(sub_pattern, log_example)
        if self.fitter_mode == 0:
            self.conbine_pattern_dict[log_id] = sub_pattern
            print('sub_pattern = {0}'.format(sub_pattern))
        else:
            print(self.fragmentation_pattern_dict)

    def pattern_test(self, pattern, log_example):
        result = re.match(pattern, log_example)
        print(result.groupdict())

    def get_regular_expression(self, log_example, pattern, target_and_end):
        result = re.match(pattern, log_example)
        is_recursion = False
        if result is not None:
            square_brackets_left = result.group(1).count('[')
            square_brackets_right = result.group(1).count(']')
            big_parantheses_left = result.group(1).count('{')
            big_parantheses_right = result.group(1).count('}')
            square_list = self.get_word_index_list(result.group(1), '[', 0, [])
            big_list = self.get_word_index_list(result.group(1), '{', 0, [])
            square_list.extend(big_list)
            square_list.sort(reverse=True)
            if (square_brackets_left != square_brackets_right) and (big_parantheses_left != big_parantheses_right):
                is_recursion = True
                if len(square_list) > 0:
                    for index in square_list:
                        if big_list.__contains__(index):
                            pattern = self.match_big_parantheses_left(log_example, pattern, target_and_end)
                        else:
                            pattern = self.match_square_brackets_left(log_example, pattern, target_and_end)
            elif square_brackets_left > square_brackets_right:
                is_recursion = True
                for index in square_list:
                    pattern = self.match_square_brackets_left(log_example, pattern, target_and_end)
            elif big_parantheses_left > big_parantheses_right:
                is_recursion = True
                for index in big_list:
                    pattern = self.match_big_parantheses_left(log_example, pattern, target_and_end)
            # self.pattern_test(pattern, log_example)
        if is_recursion is True:
            return self.get_regular_expression(log_example, pattern, target_and_end)
        else:
            return pattern

    def result_resolve_fragmentation(self, log_id, log_example, sheet, data_row, target_dict):
        pattern_list = self.fragmentation_pattern_dict.get(log_id)
        for pattern in pattern_list:
            result_match = re.match(pattern, log_example)
            if result_match is not None:
                actual_result_dict = result_match.groupdict()
                target_result_dict = {}
                keys = []
                keys.extend(actual_result_dict.keys())
                for item in target_dict:
                    if target_dict.get(item) is None:
                        continue
                    target_result = str(sheet.cell(data_row, item).value)
                    target_title = target_dict.get(item).split("|")[0]
                    target_result_dict[target_title] = target_result
                for result_title in keys:
                    actual_result = self.get_result(actual_result_dict.get(result_title))
                    result = target_result_dict[result_title] == actual_result
                    print('{0} 实际结果为{1}预期结果为{2} {3}预期'.format(result_title, actual_result, target_result_dict[result_title],"符合" if result else "不符合"))
                    if result is False:
                        raise Exception(
                            '{0} 实际结果为{1}预期结果为{2}不符合预期， 请检查xlsx'.format(result_title, actual_result, target_result_dict[result_title]))

    def get_result(self, result):
        for split_word in self.result_split_word_list:
            result_value = self.get_result_value(result, split_word)
            if result is not None:
                return result_value

    def get_result_value(self, result, split_rule):
        if result.__contains__('='):
            result_match = re.match('.*?{0}(.*)'.format(split_rule), result)
            if result_match is None:
                return None
            else:
                return result_match.group(1)
        return None


    def result_resolve_conbine(self, log_id, log_example, sheet, data_row, target_dict):
        pattern = self.conbine_pattern_dict[log_id]
        match = re.match(pattern, log_example)
        result_dict = {}
        if match is not None:
            result_dict = match.groupdict()
        else:
            raise Exception("检查失败")
        for item in target_dict:
            if target_dict.get(item) is None:
                continue
            target_result = str(sheet.cell(data_row, item).value)
            target_title = target_dict.get(item).split("|")[0]
            keys = []
            keys.extend(result_dict)
            if keys.__contains__(target_title):
                # print(' result_dict.get(target_title) = {0}  target_dict = {1}'.format( result_dict.get(target_title), target_result))
                actual_result = self.get_result(result_dict.get(target_title))
                result = actual_result == target_result
                print('{0}实际结果为{1}预期结果为{2} {3}预期'.format(target_title, actual_result, target_result,
                                                               "符合" if result else "不符合"))
                if result is False:
                    raise Exception('{0} 实际结果为{1}预期结果为{2}不符合预期， 请检查xlsx'.format(target_title, actual_result, target_result))

    def match_square_brackets_left(self, log_example, pattern, target_and_end):
        patternold = pattern
        pattern = pattern.replace('.*?)'+ target_and_end[1] + '.*', '')
        pattern = pattern + '.*?].*?'
        pattern = pattern + ')' + target_and_end[1] + '.*'
        result = re.match(pattern, log_example)
        if result is not None:
            return pattern
        else:
            return patternold


    def match_big_parantheses_left(self, log_example, pattern, target_and_end):
        patternold = pattern
        pattern = pattern.replace('.*?)'+ target_and_end[1] + '.*', '')
        pattern = pattern + '.*?}.*?'
        pattern = pattern + ')'+ target_and_end[1] + '.*'
        result = re.match(pattern, log_example)
        if result is not None:
            return pattern
        else:
            return patternold



    def get_word_index_list(self, line, word, start_index, list):
        try:
            index = line.index(word, start_index, len(line))
            list.append(index)
            start_index = index + 1
            return self.get_word_index_list(line, word, start_index, list)
        except Exception as e:
            return list

    def get_log_tag_pattern(self, logline):
        tag_pattern = '.*\w/(\S+)\(\s*\d+\)'
        return tag_pattern

if __name__ == '__main__':
    te = retest()
    te.load_xlsx()